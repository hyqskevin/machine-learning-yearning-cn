---
title: 优化验证测试的一般形式
permalink: /docs/ch45/
---

你可以在如下情况运用优化验证测试，给定输入 $x$ ，且知道如何计算  $\text{Score}_x (y)$  来表示 $y$ 对输入 $x$ 的响应好坏。此外，你正在使用一种近似算法来尽可能地找到 $ \arg \max_y \text{Score}_x(y)$ ，但却怀疑该搜索算法有时候并不能找到最大值。在我们先前提到的语音识别的例子中，$x=A$ 代表某个音频片段， $y=S$ 代表输出的转录。

假设 $y^\*​$ 是 “正确的” 输出，可算法输出了 $y_{out}​$ . 此时的关键在于测量是否有 $\text{Score}\_x(y^\*) \ge \text{Score}\_x(y\_{out})​$ . 如果该不等式成立，我们便可以将误差归咎于优化算法。（请参考前一章的内容，以确保你理解这背后的逻辑。）否则，我们将误差归咎于  $\text{Score}_x (y)​$  的计算方式。

让我们再看一个例子：假设你正在构建一个中译英的机器翻译系统，输入一个中文句子$C$ ，并计算出每一个可能的翻译句子 $E$ 的得分 $\text{Score}_C(E)$，例如，你可以使用 $\text{Score}_C(E)=P(E\|C)$，表示给定输入句子 $C$ ，对应翻译句子为 $E$ 的概率。

你的算法将通过计算下面的公式来进行句子的翻译：
$$
\text{Output}=\arg \max_E \text{Score}_C(E)
$$
然而所有可能的英语句子构成的集合太大了，所以你将依赖于启发式搜索算法。 

假设你的算法输出了一个错误的翻译 $E_{out}​$，而不是正确的翻译 $E^\*​$ . 优化验证测试会要求你计算是否有 $\text{Score}\_C (E^*) \gt  \text{Score}\_C (E)_{out}​$ . 如果这个不等式成立，表明 $\text{Score}_C(.)​$ 正确地辨认  $E^\*​$ 是一个更好的输出；因此你可以将把这个误差归咎于近似搜索算法。否则，你可以将这个误差归咎于 $\text{Score}_C(.)​$ 的计算方式。

在人工智能领域，这是一种非常常见的 “设计模式”，首先要学习一个近似的得分函数 $\text{Score}_X(.)$ ，然后使用近似最大化算法。如果你能够发现这种模式，就能够使用优化验证测试来理解造成误差的来源。  

